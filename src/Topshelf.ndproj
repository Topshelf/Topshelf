<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="Topshelf" Platform="DotNet">
  <OutputDir KeepHistoric="True" KeepXmlFiles="True">C:\development\Topshelf\src\NDependOut</OutputDir>
  <Assemblies>
    <Name>Topshelf</Name>
  </Assemblies>
  <FrameworkAssemblies>
    <Name>mscorlib</Name>
    <Name>System.ServiceProcess</Name>
    <Name>Magnum</Name>
    <Name>System.Configuration.Install</Name>
    <Name>System.Configuration</Name>
    <Name>log4net</Name>
    <Name>System</Name>
    <Name>System.CoreEx</Name>
    <Name>System.Management</Name>
    <Name>System.Core</Name>
    <Name>System.Reactive</Name>
  </FrameworkAssemblies>
  <Dirs>
    <Dir>C:\Windows\Microsoft.NET\Framework\v4.0.30319</Dir>
    <Dir>C:\Windows\Microsoft.NET\Framework\v4.0.30319\WPF</Dir>
    <Dir>C:\development\Topshelf\src\bin</Dir>
  </Dirs>
  <Report XslPath="">
    <Section Enabled="True">Application Metrics</Section>
    <Section Enabled="True">Assemblies Metrics</Section>
    <Section Enabled="True">VisualNDepend View</Section>
    <Section Enabled="True">Assemblies Abstractness vs. Instability</Section>
    <Section Enabled="True">Assemblies Dependencies</Section>
    <Section Enabled="True">Assemblies Dependencies Diagram</Section>
    <Section Enabled="True">Assemblies build order</Section>
    <Section Enabled="True">NDepend information and warnings</Section>
    <Section Enabled="True">CQL Queries and Constraints</Section>
    <Section Enabled="True">Types Metrics</Section>
    <Section Enabled="False">Types Dependencies</Section>
  </Report>
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="MostRecentBuildAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="MostRecentBuildAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" />
  <CoverageFiles UncoverableAttribute="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <CQLQueries>
    <CQLGroup Name="Code Quality" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Quick summary of methods to refactor&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT \r\n   TOP 10 METHODS /*OUT OF "YourGeneratedCode" */ WHERE \r\n\r\n                                    // Metrics' definitions\r\n  ( NbLinesOfCode &gt; 30 OR           // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode\r\n    NbILInstructions &gt; 200 OR       // http://www.ndepend.com/Metrics.aspx#NbILInstructions\r\n    CyclomaticComplexity &gt; 20 OR    // http://www.ndepend.com/Metrics.aspx#CC\r\n    ILCyclomaticComplexity &gt; 50 OR  // http://www.ndepend.com/Metrics.aspx#ILCC\r\n    ILNestingDepth &gt; 4 OR           // http://www.ndepend.com/Metrics.aspx#ILNestingDepth\r\n    NbParameters &gt; 5 OR             // http://www.ndepend.com/Metrics.aspx#NbParameters\r\n    NbVariables &gt; 8 OR              // http://www.ndepend.com/Metrics.aspx#NbVariables\r\n    NbOverloads &gt; 6 )               // http://www.ndepend.com/Metrics.aspx#NbOverloads\r\n     AND \r\n\r\n  // Here are some ways to avoid taking account of generated methods.\r\n  !( NameIs "InitializeComponent()" OR\r\n     // NDepend.CQL.GeneratedAttribute is defined in \r\n     // the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n     // You can define your own attribute to mark "Generated".\r\n     HasAttribute "OPTIONAL:NDepend.CQL.GeneratedAttribute") </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too big (NbLinesOfCode)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n   NbLinesOfCode &gt; 30 \r\n   ORDER BY NbLinesOfCode DESC\r\n\r\n// METHODS WHERE NbLinesOfCode &gt; 30 are extremely complex \r\n// and should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the NbLinesOfCode metric here \r\n// http://www.ndepend.com/Metrics.aspx#NbLinesOfCode</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too big (NbILInstructions)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  NbILInstructions &gt; 200 \r\n  ORDER BY NbILInstructions DESC\r\n\r\n// METHODS WHERE NbILInstructions &gt; 200 are extremely complex \r\n// and should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the NbILInstructions metric here \r\n// http://www.ndepend.com/Metrics.aspx#NbILInstructions</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (CyclomaticComplexity)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  CyclomaticComplexity &gt; 20 \r\n  ORDER BY CyclomaticComplexity DESC\r\n\r\n// METHODS WHERE CyclomaticComplexity &gt; 15 are hard to understand and maintain.\r\n// METHODS WHERE CyclomaticComplexity &gt; 30 are extremely complex \r\n// and should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the CyclomaticComplexity metric here \r\n// http://www.ndepend.com/Metrics.aspx#CC</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (ILCyclomaticComplexity)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  ILCyclomaticComplexity &gt; 40 \r\n  ORDER BY ILCyclomaticComplexity DESC\r\n\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 20 \r\n// are hard to understand and maintain.\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 40 \r\n// are extremely complex and should be split \r\n// in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the ILCyclomaticComplexity metric here \r\n// http://www.ndepend.com/Metrics.aspx#ILCC</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (ILNestingDepth)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  ILNestingDepth &gt; 4 \r\n  ORDER BY ILNestingDepth DESC\r\n\r\n// METHODS WHERE ILNestingDepth &gt; 4 are hard \r\n// to understand and maintain. \r\n// METHODS WHERE ILNestingDepth &gt; 8 is higher \r\n// than 8 are extremely complex \r\n// and should be split in smaller methods \r\n// (except if they are automatically generated by a tool). \r\n// See the definition of the NbILInstructions metric here \r\n// http://www.NDepend.com/Metrics.aspx#ILNestingDepth</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods poorly commented (PercentageComment)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  PercentageComment &lt; 20 AND \r\n  NbLinesOfCode &gt; 10  \r\n  ORDER BY PercentageComment ASC\r\n\r\n// METHODS WHERE %Comment &lt; 20 and that have \r\n// at least 10 lines of code should be more commented.\r\n// See the definition of the PercentageComment metric here \r\n// http://www.ndepend.com/Metrics.aspx#PercentageComment</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many parameters (NbParameters)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  NbParameters &gt; 5 \r\n  ORDER BY NbParameters DESC\r\n\r\n// METHODS WHERE NbParameters &gt; 5 might be painful to call \r\n// and might degrade performance. You should prefer using \r\n// additional properties/fields to the declaring type to \r\n// handle numerous states. Another alternative is to provide \r\n// a class or structure dedicated to handle arguments passing \r\n// (for example see the class System.Diagnostics.ProcessStartInfo \r\n// and the method System.Diagnostics.Process.Start(ProcessStartInfo))\r\n// See the definition of the NbParameters metric here \r\n// http://www.ndepend.com/Metrics.aspx#NbParameters</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many local variables (NbVariables)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  NbVariables &gt; 15 \r\n  ORDER BY NbVariables DESC\r\n\r\n// METHODS WHERE NbVariables &gt; 8 are hard to understand and maintain.\r\n// METHODS WHERE NbVariables &gt; 15 are extremely complex \r\n// and should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the Nbvariables metric here \r\n// http://www.ndepend.com/Metrics.aspx#Nbvariables</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many overloads (NbOverloads)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  NbOverloads &gt; 6 \r\n  ORDER BY NbOverloads DESC\r\n\r\n// METHODS WHERE NbOverloads &gt; 6 might \r\n// be a problem to maintain and provoke higher coupling \r\n// than necessary. \r\n// This might also reveal a potential misused of the \r\n// C# and VB.NET language that since C#3 and VB9 support \r\n// object initialization. This feature helps reducing the number \r\n// of constructors of a class.\r\n// See the definition of the NbOverloads metric here \r\n// http://www.ndepend.com/Metrics.aspx#NbOverloads</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Messages should be immutable&lt;/Name&gt;
SELECT TYPES
WHERE FullNameLike "Messages" 
AND !IsImmutable </CQLQuery>
      <CQLGroup Name="Type Metrics" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with too many methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  NbMethods &gt; 20 \r\n  ORDER BY NbMethods DESC\r\n\r\n// TYPES WHERE NbMethods &gt; 20 might be hard to \r\n// understand and maintain \r\n// but there might be cases where it is relevant \r\n// to have a high value for NbMethods. \r\n// For example, the System.Windows.Forms.DataGridView \r\n// standard class has more than 1000 methods.\r\n// See the definition of the NbMethods metric here \r\n// http://www.ndepend.com/Metrics.aspx#NbMethods</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with too many fields&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  NbFields &gt; 20 AND \r\n  !IsEnumeration \r\n  ORDER BY NbFields DESC\r\n\r\n// TYPES WHERE NbFields &gt; 20 AND !IsEnumeration \r\n// might be hard to understand and maintain \r\n// but there might be cases where it is relevant \r\n// to have a high value for NbFields. \r\n// For example, the System.Windows.Forms.Control \r\n// standard class has more than 200 fields. \r\n// The value of the metric NbFields might be a better \r\n// indicator of complex type.\r\n// See the definition of the NbFields metric here \r\n// http://www.ndepend.com/Metrics.aspx#NbFields</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with poor cohesion (LCOM)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  LCOM &gt; 0.8 AND \r\n  NbFields &gt; 10 AND \r\n  NbMethods &gt;10 \r\n  ORDER BY LCOM DESC\r\n\r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 \r\n// AND NbMethods &gt;10 might be problematic. \r\n// However, it is very hard to avoid such \r\n// non-cohesive types. The LCOMHS metric\r\n// is often considered as more efficient to \r\n// detect non-cohesive types.\r\n// See the definition of the LCOM metric here \r\n// http://www.ndepend.com/Metrics.aspx#LCOM</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with poor cohesion (LCOMHS)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  LCOMHS &gt; 0.95 AND \r\n  NbFields &gt; 10 AND \r\n  NbMethods &gt;10 \r\n  ORDER BY LCOMHS DESC\r\n\r\n// TYPES WHERE LCOMHS &gt; 1.0 AND NbFields &gt; 10 AND \r\n// NbMethods &gt;10 should be avoided. \r\n// Note that this constraint is stronger \r\n// than the constraint \r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10. \r\n// See the definition of the LCOMHS metric here \r\n// http://www.ndepend.com/Metrics.aspx#LCOMHS</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Code Quality from Now!" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">\r\n      // &lt;Name&gt;From now, all methods added or refactored should respect basic quality principles&lt;/Name&gt;\r\n      WARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE\r\n\r\n      // *** Only new or modified methods since Baseline for Comparison ***\r\n      (WasAdded OR CodeWasChanged) AND\r\n\r\n      // Low Quality methods            // Metrics' definitions\r\n      (  NbLinesOfCode &gt; 30 OR          // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode\r\n      NbILInstructions &gt; 200 OR      // http://www.ndepend.com/Metrics.aspx#NbILInstructions\r\n      CyclomaticComplexity &gt; 20 OR   // http://www.ndepend.com/Metrics.aspx#CC\r\n      ILCyclomaticComplexity &gt; 50 OR // http://www.ndepend.com/Metrics.aspx#ILCC\r\n      ILNestingDepth &gt; 4 OR          // http://www.ndepend.com/Metrics.aspx#ILNestingDepth\r\n      NbParameters &gt; 5 OR            // http://www.ndepend.com/Metrics.aspx#NbParameters\r\n      NbVariables &gt; 8 OR             // http://www.ndepend.com/Metrics.aspx#NbVariables\r\n      NbOverloads &gt; 6 )              // http://www.ndepend.com/Metrics.aspx#NbOverloads\r\n\r\n\r\n      // This constraint warns if a method with\r\n      // low-quality has been added or refactored.\r\n      // With NDepend and such constraint, you can\r\n      // Ensure Quality From Now! as explained here:\r\n      // http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx\r\n\r\n      // To run this constraint properly 2 analysis\r\n      // must be compared. This can be done throught the menu:\r\n      //     NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n      // This can be done at analysis time throught the menu:\r\n      //   Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n    </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">\r\n      // &lt;Name&gt;From now, all types added or refactored should respect basic quality principles&lt;/Name&gt;\r\n      WARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE\r\n\r\n      // *** Only match new or modified types since Baseline for Comparison ***\r\n      (WasAdded OR CodeWasChanged) AND\r\n\r\n      // Low Quality types     Metrics' definitions are available here:\r\n      //                       http://www.ndepend.com/Metrics.aspx#MetricsOnTypes\r\n      (  // Types with too many methods\r\n      NbMethods &gt; 20 OR\r\n\r\n      // Types with too many fields\r\n      ( NbFields &gt; 20 AND\r\n      !IsEnumeration) OR\r\n\r\n      // Types with poor cohesion\r\n      ( LCOMHS &gt; 0.95 AND\r\n      NbFields &gt; 10 AND\r\n      NbMethods &gt; 10) OR\r\n\r\n      // Complex Types that use more than 50 other types\r\n      TypeCe &gt; 50  )\r\n\r\n\r\n      // This constraint warns if a type with\r\n      // low-quality has been added or refactored.\r\n      // With NDepend and such constraint, you can\r\n      // Ensure Quality From Now! as explained here:\r\n      // http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx\r\n\r\n      // To run this constraint properly 2 analysis\r\n      // must be compared. This can be done throught the menu:\r\n      //     NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n      // This can be done at analysis time throught the menu:\r\n      //   Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n    </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">\r\n      // &lt;Name&gt;From now, all methods added or refactored should be 100% covered by tests&lt;/Name&gt;\r\n      WARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE\r\n\r\n      // Match methods new or modified since Baseline for Comparison...\r\n      (WasAdded OR CodeWasChanged) AND\r\n\r\n      // ...that are not 100% covered by tests\r\n      PercentageCoverage &lt; 100\r\n\r\n\r\n      // This constraint warns if a method has been\r\n      // added or refactored and hasn't been 100% covered\r\n      // by tests. With NDepend and such constraint,\r\n      // you can Ensure Quality From Now! as explained here:\r\n      // http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx\r\n\r\n      // To run this constraint properly 2 analysis\r\n      // must be compared. This can be done throught the menu:\r\n      //     NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n      // This can be done at analysis time throught the menu:\r\n      //   Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n      // To run this constraint properly coverage data\r\n      // must be gathered from NCover™ or Visual Studio™ Coverage.\r\n      // This can be done throught the menu:\r\n      //   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n      // This can be done at analysis time throught the menu:\r\n      // Project Properties -&gt; Analysis -&gt; Code Coverage\r\n      // More information on how to import coverage data here:\r\n      // http://www.ndepend.com/Coverage.aspx\r\n    </CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Design" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assembly should not contain namespaces dependency cycles&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 ASSEMBLIES WHERE \r\n  ContainsNamespaceDependencyCycle\r\n\r\n// Dependency cycles between namespaces must be avoided \r\n// in order to have a levelized and comprehensive design.\r\n// More info available on the screencast 'Reduce the complexity' \r\n// http://s3.amazonaws.com/NDependOnlineDemos/NDependReducingComplexity_viewlet_swf.html\r\n// You can also read this article \r\n// http://www.theserverside.net/tt/articles/showarticle.tss?id=ControllingDependencies</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Type should not have too many responsabilities (Efferent Coupling)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  TypeCe &gt; 50 \r\n  ORDER BY TypeCe DESC \r\n\r\n// The Efferent Coupling (TypeCe) for a particular type is \r\n// the number of types it directly depends on. Notice that \r\n// types declared in tier assemblies are taken into account. \r\n\r\n// Types that depends on too many others type (more than 50) \r\n// are complex and have more than one responsability. They \r\n// are good candidate for refactoring.\r\n\r\n// More information available in this article:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/02/15/code-metrics-on-coupling-dead-code-design-flaws-and-re-engineering.aspx\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;A stateless class or structure might be turned into a static type&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE\r\n  SizeOfInst ==0 AND\r\n\r\n  // For accuracy, this constraint doesn't take\r\n  // account of types that implement some interfaces.\r\n  // and classes that have a base class and don't\r\n  // derive directly from System.Object, or classes\r\n  // that have sub-classes children.  \r\n  NbInterfacesImplemented == 0 AND                           \r\n  ((IsClass AND DepthOfInheritance == 1   \r\n            AND NbChildren == 0)          \r\n    OR IsStructure) AND                   \r\n  !IsStatic AND\r\n  !IsGeneric\r\n  // this rule indicates stateless types that might \r\n  // eventually be turned into static classes.\r\n  // See the definition of the SizeOfInst metric here \r\n  // http://www.ndepend.com/Metrics.aspx#SizeOfInst</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Class shouldn't be too deep in inheritance tree &lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  DepthOfInheritance &gt;= 6 \r\n  ORDER BY DepthOfInheritance DESC \r\n\r\n// Branches too long in the derivation should be avoided.\r\n// See the definition of the DepthOfInheritance metric here \r\n// http://www.ndepend.com/Metrics.aspx#DIT\r\n \r\n// You can discard specific classes with by-design high \r\n// DepthOfInheritance with such condition for example:\r\n// AND !DeriveFrom "System.Windows.Forms.Form" </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Class with no descendant should be sealed if possible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsClass AND \r\n  NbChildren ==0 AND \r\n  !IsSealed AND \r\n  !IsStatic \r\n  // AND !IsPublic &lt;-- You might want to add this condition \r\n  //                   if you are developping a framework\r\n  //                   with classes that are intended to be \r\n  //                   sub-classed by your clients.\r\n  ORDER BY NbLinesOfCode</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Classes that are candidate to be turned into Structures&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsClass AND\r\n  !IsStatic AND\r\n  SizeOfInst &gt; 0 AND\r\n  SizeOfInst &lt;= 16 AND    // Structure instance must not be too big, \r\n                          // else it degrades performance.\r\n\r\n  NbChildren == 0 AND     // Must not have children\r\n\r\n  DepthOfInheritance == 1 // Must derive directly from System.Object\r\n\r\n  // AND IsSealed    &lt;-- You might want to add this condition \r\n  //                     to restreint the set.\r\n  // AND IsImmutable &lt;-- Structures should be immutable type.\r\n  // AND !IsPublic   &lt;-- You might want to add this condition if \r\n  //                     you are developping a framework with classes \r\n  //                     that are intended to be sub-classed by \r\n  //                     your clients.\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid namespaces with few types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 NAMESPACES WHERE \r\n  NbTypes &lt; 5 \r\n  ORDER BY NbTypes ASC \r\n\r\n// Make sure that there is a logical organization \r\n// to each of your namespaces, and that there is a \r\n// valid reason for putting types in a sparsely \r\n// populated namespace. Namespaces should contain \r\n// types that are used together in most scenarios. \r\n// When their applications are mutually exclusive, \r\n// types should be located in separate namespaces</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Nested types should not be visible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsNested AND \r\n  !IsPrivate AND \r\n  !IsInFrameworkAssembly \r\n\r\n// A nested type is a type declared within the \r\n// scope of another type. Nested types are useful \r\n// for encapsulating private implementation details \r\n// of the containing type. Used for this purpose, \r\n// nested types should not be externally visible. \r\n// Do not use externally visible nested types for \r\n// logical grouping or to avoid name collisions; \r\n// instead, use namespaces.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid empty interfaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsInterface AND \r\n  NbMethods == 0\r\n\r\n// Interfaces define members that provide a behavior \r\n// or usage contract. The functionality described by \r\n// the interface can be adopted by any type, \r\n// regardless of where the type appears in the \r\n// inheritance hierarchy. A type implements an \r\n// interface by providing implementations for the \r\n// interface's members. An empty interface does not \r\n// define any members, and as such, does not define \r\n// a contract that can be implemented.\r\n\r\n// If your design includes empty interfaces that \r\n// types are expected to implement, you are probably \r\n// using an interface as a marker, or a way of \r\n// identifying a group of types. If this identification \r\n// will occur at runtime, the correct way to accomplish\r\n// this is to use a custom attribute. Use the presence \r\n// or absence of the attribute, or the attribute's \r\n// properties, to identify the target types. If the \r\n// identification must occurs at compile time, then using \r\n// an empty interface is acceptable.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Declare types in namespaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\n  NameIs "" AND \r\n  !IsInFrameworkAssembly \r\n\r\n// Types are declared within namespaces to \r\n// prevent name collisions, and as a way of \r\n// organizing related types in an object hierarchy. \r\n// Types outside any named namespace are in a \r\n// global namespace that cannot be referenced \r\n// in code. If an anonymous namespace can be found, \r\n// it means that it contains types outside of namespaces.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Empty static constructor can be discarded&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  IsClassConstructor AND \r\n  NbLinesOfCode == 0\r\n    </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assemblies with poor cohesion (RelationalCohesion)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 ASSEMBLIES WHERE \r\n  NbTypes &gt; 20 AND // Relational Cohesion metrics is relevant only if there are several types \r\n  (RelationalCohesion &lt; 1.5 OR \r\n   RelationalCohesion &gt; 4.0)\r\n\r\n// As classes inside an assembly should be strongly related, \r\n// the cohesion should be high. On the other hand, a value \r\n// which is too high may indicate over-coupling. A good range \r\n// for RelationalCohesion is 1.5 to 4.0.\r\n// See the definition of the RelationalCohesion metric here \r\n// http://www.ndepend.com/Metrics.aspx#RelationalCohesion</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assemblies that don't satisfy the Abstractness/Instability principle&lt;/Name&gt;\r\nWARN IF Percentage &gt; 15 IN SELECT ASSEMBLIES WHERE \r\n  NormDistFromMainSeq &gt; 0.7 \r\n  ORDER BY NormDistFromMainSeq DESC\r\n\r\n// See the definition of the NormDistFromMainSeq metric here \r\n// http://www.ndepend.com/Metrics.aspx#DitFromMainSeq</CQLQuery>
      <CQLGroup Name="Performance" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Instances size shouldn't be too big (SizeOfInst)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  SizeOfInst &gt; 64 \r\n  ORDER BY SizeOfInst DESC\r\n\r\n// TYPES WHERE SizeOfInst &gt; 64 might degrade performance \r\n// (depending on the number of instances created at runtime) \r\n// and might be hard to maintain. However it is not a rule \r\n// since sometime there is no alternative (the size of \r\n// instances of the System.Net.NetworkInformation.SystemIcmpV6Statistics \r\n// standard class is 2064 bytes).\r\n// See the definition of the SizeOfInst metric here \r\n// http://www.ndepend.com/Metrics.aspx#SizeOfInst</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Boxing/unboxing should be avoided (Method)&lt;/Name&gt;\r\nWARN IF Percentage &gt; 5 IN SELECT METHODS WHERE \r\n  IsUsingBoxing OR \r\n  IsUsingUnboxing \r\n\r\n// Thanks to generics, boxing and unboxing should be rare.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Boxing/unboxing should be avoided (Type)&lt;/Name&gt;\r\nWARN IF Percentage &gt; 5 IN SELECT TYPES WHERE \r\n  IsUsingBoxing OR \r\n  IsUsingUnboxing \r\n\r\n// Thanks to generics, boxing and unboxing should be rare.</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Attribute classes should be sealed&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  IsAttributeClass AND \r\n  !IsSealed AND \r\n  !IsAbstract AND \r\n  IsPublic AND \r\n  !IsInFrameworkAssembly \r\n\r\n// The .NET Framework class library provides methods \r\n// for retrieving custom attributes. By default, \r\n// these methods search the attribute inheritance \r\n// hierarchy; for example System.Attribute.GetCustomAttribute \r\n// searches for the specified attribute type, or any \r\n// attribute type that extends the specified attribute \r\n// type. Sealing the attribute eliminates the search \r\n// through the inheritance hierarchy, and can improve \r\n// performance.</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Unused Code / Dead Code" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n MethodCa == 0 AND        // Ca=0 -&gt; No Afferent Coupling -&gt; \r\n                          // The method is not used in the \r\n                          // context of this application.\r\n\r\n !IsPublic AND            // Public methods might be used by \r\n                          // client applications of your assemblies.\r\n\r\n !IsEntryPoint AND        // Main() method is not used by-design.\r\n\r\n !IsExplicitInterfaceImpl // The IL code never explicitely \r\n AND                      // calls explicit interface methods \r\n                          // implementation.\r\n\r\n !IsClassConstructor AND  // The IL code never explicitely \r\n                          // calls class constructors.\r\n\r\n !IsFinalizer             // The IL code never explicitely \r\n                          // calls finalizers.\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused fields&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n FieldCa == 0 AND  // Ca=0 -&gt; No Afferent Coupling -&gt; \r\n                   // The field is not used in the \r\n                   // context of this application.\r\n\r\n !IsPublic AND     // Although not recommended, \r\n                   // public fields might be used by \r\n                   // client applications of your \r\n                   // assemblies.\r\n\r\n !IsLiteral AND    // The IL code never explicitely \r\n                   // uses literal fields.\r\n\r\n !IsEnumValue AND  // The IL code never explicitely \r\n                   // uses enumeration value.\r\n\r\n !NameIs "value__" // Field named 'value__' are relative \r\n                   // to enumerations and the IL code \r\n                   // never explicitely uses them.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n TypeCa == 0 AND    // Ca=0 -&gt; No Afferent Coupling -&gt; \r\n                    // The type is not used in the \r\n                    // context of this application.\r\n\r\n !IsPublic AND      // Public types might be used \r\n                    // by client applications of your\r\n                    // assemblies.\r\n\r\n !NameIs "Program"  // Generally, types named Program \r\n                    // contain a Main() entry-point \r\n                    // method and this condition avoid \r\n                    // to consider such type as \r\n                    // unused code.\r\n</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Encapsulation" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields should be declared as private&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n !IsPrivate AND \r\n\r\n // These conditions filter cases where fields \r\n // doesn't represent state that should be encapsulated. \r\n !IsInFrameworkAssembly AND \r\n !IsGeneratedByCompiler AND \r\n !IsSpecialName AND \r\n !IsInitOnly AND \r\n !IsLiteral AND \r\n !IsEnumValue</CQLQuery>
      <CQLGroup Name="Methods Optimal Encapsulation" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'internal' in C#,  'Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  CouldBeInternal AND\r\n  \r\n  // Eliminate default constructor from the result.\r\n  // Whatever the visibility of the declaring class,\r\n  // default constructors are public and introduce noise\r\n  // in the current rule.\r\n  ! ( IsConstructor AND \r\n      IsPublic AND \r\n      NbILInstructions == 3)</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'protected internal' in C#,  'Protected Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  CouldBeInternalProtected</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'protected' in C#,  'Protected' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  CouldBeProtected</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  CouldBePrivate</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  ShouldBePublic \r\n\r\n// The keyword 'ShouldBePublic' shows code elements \r\n// declared as 'internal\Friend' that are used outside \r\n// of their assembly thanks to the Attribute \r\n// System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="Types Optimal Encapsulation" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  CouldBeInternal</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as 'protected internal' in C#,  'Protected Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  CouldBeInternalProtected</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as 'protected' in C#,  'Protected' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  CouldBeProtected</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  CouldBePrivate</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  ShouldBePublic \r\n\r\n// The keyword 'ShouldBePublic' shows code elements \r\n// declared as 'internal\Friend' that are used \r\n// outside of their assembly thanks to the Attribute \r\n// System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="Fields Optimal Encapsulation" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  CouldBeInternal</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'protected internal' in C#,  'Protected Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  CouldBeInternalProtected</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'protected' in C#,  'Protected' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  CouldBeProtected</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  CouldBePrivate</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT FIELDS WHERE \r\n  ShouldBePublic \r\n\r\n// The keyword 'ShouldBePublic' shows code elements \r\n// declared as 'internal\Friend' that are used \r\n// outside of their assembly thanks to the Attribute \r\n// System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Diff / Changes / Evolution" Active="True">
      <CQLGroup Name="API Breaking Changes" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS\r\nWHERE \r\n  IsPublic AND \r\n  (VisibilityWasChanged OR WasRemoved)\r\n\r\n// This constraint warns if a public method is \r\n// not public anymore or if it has been removed.\r\n// This can break the code of your clients.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES\r\nWHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)\r\n\r\n// This constraint warns if a public type is not public anymore or if it has been removed.\r\n// This can break the code of your clients.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Interfaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES\r\nWHERE IsInterface AND IsPublic AND (WasChanged AND !CommentsWereChanged)\r\n\r\n// This constraint warns if a public interface has been changed, but not because of comment change.\r\n// This can break the code of your clients that implements such interface.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Analysis Comparison</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="Changes Summary" Active="False">
        <CQLGroup Name="Methods" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods added&lt;/Name&gt;\r\nSELECT METHODS WHERE WasAdded\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods removed&lt;/Name&gt;\r\nSELECT METHODS WHERE WasRemoved \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where code was changed&lt;/Name&gt;\r\nSELECT METHODS WHERE CodeWasChanged \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where comments were changed&lt;/Name&gt;\r\nSELECT METHODS WHERE CommentsWereChanged  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where visibility was changed&lt;/Name&gt;\r\nSELECT METHODS WHERE VisibilityWasChanged  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods that became obsolete&lt;/Name&gt;\r\nSELECT METHODS WHERE BecameObsolete  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Fields" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Fields added&lt;/Name&gt;\r\nSELECT FIELDS WHERE WasAdded\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Fields removed&lt;/Name&gt;\r\nSELECT FIELDS WHERE WasRemoved \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Types" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types added&lt;/Name&gt;\r\nSELECT TYPES WHERE WasAdded\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types removed&lt;/Name&gt;\r\nSELECT TYPES WHERE WasRemoved \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where code was changed&lt;/Name&gt;\r\nSELECT TYPES WHERE CodeWasChanged \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where comments were changed&lt;/Name&gt;\r\nSELECT TYPES WHERE CommentsWereChanged  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where visibility was changed&lt;/Name&gt;\r\nSELECT TYPES WHERE VisibilityWasChanged  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tyoes that became obsolete&lt;/Name&gt;\r\nSELECT TYPES WHERE BecameObsolete  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Namespaces" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces added&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE WasAdded\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces removed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE WasRemoved \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces where code was changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE CodeWasChanged \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces where comments were changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE CommentsWereChanged  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Assemblies" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies added&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE WasAdded\r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies removed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE WasRemoved \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies where code was changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE CodeWasChanged \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies where comments were changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE CommentsWereChanged  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
        </CQLGroup>
        <CQLGroup Name="Tier Code Usage" Active="False">
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Methods that were not used and that are now used&lt;/Name&gt;\r\nSELECT METHODS WHERE IsUsedRecently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Methods that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT METHODS WHERE IsNotUsedAnymore  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types that were not used and that are now used&lt;/Name&gt;\r\nSELECT TYPES WHERE IsUsedRecently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT TYPES WHERE IsNotUsedAnymore  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types where usage changed&lt;/Name&gt;\r\nSELECT TYPES WHERE IsUsedDifferently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces that were not used and that are now used&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsUsedRecently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsNotUsedAnymore  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces where usage changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsUsedDifferently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies that were not used and that are now used&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsUsedRecently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsNotUsedAnymore  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies where usage changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsUsedDifferently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Fields that were not used and that are now used&lt;/Name&gt;\r\nSELECT FIELDS WHERE IsUsedRecently \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
          <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Fields that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT FIELDS WHERE IsNotUsedAnymore  \r\n\r\n// To run this constraint properly 2 analysis \r\n// must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison</CQLQuery>
        </CQLGroup>
      </CQLGroup>
      <CQLGroup Name="Test Coverage of Changes Summary" Active="False">
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed 100% covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage == 100 AND \r\n  CodeWasChanged \r\n  ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added 100% covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  WasAdded AND \r\n  PercentageCoverage == 100 \r\n  ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed partially covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &lt; 100 AND \r\n  PercentageCoverage &gt; 0 AND\r\n  CodeWasChanged \r\n  ORDER BY PercentageCoverage DESC , \r\n           NbLinesOfCodeCovered , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added partially covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &lt; 100 AND \r\n  PercentageCoverage &gt; 0 AND\r\n  WasAdded  \r\n  ORDER BY PercentageCoverage DESC , \r\n           NbLinesOfCodeCovered , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed not covered at all&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage == 0 AND \r\n  CodeWasChanged \r\n  ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added not covered at all&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage == 0 AND \r\n  WasAdded \r\n  ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Compare -&gt; Define the project's Baseline for Comparison\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Test Coverage" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on methods 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n/// '100% covered' methods.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on methods 100% Branch-covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.FullBranchCoveredAttribute" AND \r\n  PercentageBranchCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// '100% branch covered' methods.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n// The metric BranchCoverage is not available if you are using Visual Studio™ Coverage.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on type 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// '100% covered' types.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on assembly 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// '100% covered' assemblies.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on methods at least 95% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND \r\n  PercentageCoverage &lt; 95\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// 'at least 95% Covered' methods.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on types at least 95% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND \r\n  PercentageCoverage &lt; 95\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// 'at least 95% Covered' types.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on assemblies at least 95% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND \r\n  PercentageCoverage &lt; 95\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// 'at least 95% Covered' assemblies.\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Complex methods should be 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS \r\n /*OUT OF "YourGeneratedCode" */ \r\n WHERE \r\n     // These metrics' definitions are available here: \r\n     // http://www.ndepend.com/Metrics.aspx#MetricsOnMethods\r\n     (  NbILInstructions &gt; 200 OR \r\n        ILCyclomaticComplexity &gt; 50 OR \r\n        ILNestingDepth &gt; 4 OR\r\n        NbParameters &gt; 5 OR \r\n        NbVariables &gt; 8 OR\r\n        NbOverloads &gt; 6 ) AND \r\n     PercentageCoverage &lt; 100\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      <CQLGroup Name="Test Coverage Summary" Active="False">
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 100% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage == 100\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 100% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  PercentageCoverage == 100\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 100% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE \r\n  PercentageCoverage == 100\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 100% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE \r\n  PercentageCoverage == 100\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods not covered&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage == 0\r\n  ORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types not covered&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  PercentageCoverage == 0\r\n  ORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces not covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE \r\n  PercentageCoverage == 0\r\n  ORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies not covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE \r\n  PercentageCoverage == 0\r\n  ORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 95% to 99% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &gt;= 95 AND \r\n  PercentageCoverage &lt;= 99 \r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 95% to 99% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  PercentageCoverage &gt;= 95 AND \r\n  PercentageCoverage &lt;= 99 \r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 95% to 99% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE \r\n  PercentageCoverage &gt;= 95 AND \r\n  PercentageCoverage &lt;= 99 \r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 95% to 99% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE \r\n  PercentageCoverage &gt;= 95 AND \r\n  PercentageCoverage &lt;= 99 \r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 70% to 94% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &gt;= 70 AND \r\n  PercentageCoverage &lt;= 94\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 70% to 94% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  PercentageCoverage &gt;= 70 AND \r\n  PercentageCoverage &lt;= 94\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 70% to 94% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE \r\n  PercentageCoverage &gt;= 70 AND \r\n  PercentageCoverage &lt;= 94\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 70% to 94% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE \r\n  PercentageCoverage &gt;= 70 AND \r\n  PercentageCoverage &lt;= 94\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 1% to 69% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &gt;= 1 AND \r\n  PercentageCoverage &lt;= 69\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 1% to 69% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  PercentageCoverage &gt;= 1 AND \r\n  PercentageCoverage &lt;= 69\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 1% to 69% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE \r\n  PercentageCoverage &gt;= 1 AND \r\n  PercentageCoverage &lt;= 69\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 1% to 69% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE \r\n  PercentageCoverage &gt;= 1 AND \r\n  PercentageCoverage &lt;= 69\r\n  ORDER BY NbLinesOfCode DESC , \r\n           NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be \r\n// gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Purity / Immutability / Side-Effects" Active="True">
      <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields should be marked as ReadOnly when possible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  IsImmutable AND \r\n  !IsInitOnly\r\n\r\n// A field that matches the condition IsImmutable \r\n// is a field that is assigned only by constructors \r\n// of its class.\r\n// For an instance field, this means its value \r\n// will remain constant throught the lifetime \r\n// of the object.\r\n// For a static field, this means its value will \r\n// remain constant throught the lifetime of the \r\n// program.\r\n// In both cases, such field can safely be marked \r\n// with the C# readonly keyword \r\n// (ReadOnly in VB.NET).\r\n\r\n// The condition IsInitOnly matches fields that \r\n// are marked with the C# readonly keyword \r\n// (ReadOnly in VB.NET).\r\n\r\n\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Structures should be immutable&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  IsStructure AND \r\n  !IsImmutable AND \r\n  !IsInFrameworkAssembly\r\n\r\n// It is deemed as a good practice to make \r\n// your structure immutable.\r\n// An object is immutable if its state doesn’t \r\n// change once the object has been created. \r\n// Consequently, a structure is immutable if \r\n// its instances are immutable.\r\n// Immutable types naturally simplify code by \r\n// limiting side-effects.\r\n// See some explanations on immutability and \r\n// how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Regression on immutable types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND \r\n  !IsImmutable\r\n\r\n// An object is immutable if its state doesn’t \r\n// change once the object has been created. \r\n// Consequently, a class or a structure is \r\n// immutable if its instances are immutable.\r\n// Immutable types naturally simplify code by \r\n// limiting side-effects.\r\n// See some explanations on immutability and how \r\n// NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n\r\n// NDepend.CQL.ImmutableAttribute is defined in \r\n// the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag \r\n// 'immutable' types.\r\n\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Regression on pure methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND \r\n  ( ChangesObjectState OR ChangesTypeState ) AND\r\n  NbLinesOfCode &gt; 0\r\n\r\n// A method is pure if its execution doesn’t change \r\n// the value of any instance or static field. \r\n// Pure methods naturally simplify code by limiting \r\n// side-effects.\r\n// See some explanations on immutability / purity and \r\n// how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n\r\n// NDepend.CQL.PureAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'pure' methods.\r\n\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Missing usage of ImmutableAttribute&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n  !HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND \r\n  IsImmutable\r\n\r\n// Types matched by this query are immutable but \r\n// are not tagged with the ImmutableAttribute.\r\n// The benefit of tagging them with the ImmutableAttribute \r\n// is that the constraint 'Regression on immutable types' \r\n// will warn when the immutability of a type gets broken.\r\n\r\n// NDepend.CQL.ImmutableAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'immutable' types.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Missing usage of PureAttribute&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  !HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND \r\n  !ChangesObjectState AND !ChangesTypeState AND\r\n  NbLinesOfCode &gt; 0\r\n\r\n// Methods matched by this query are pure but \r\n// are not tagged with the PureAttribute.\r\n// The benefit of tagging them with the PureAttribute \r\n// is that the constraint 'Regression on pure methods'\r\n// will warn when the purity of a method gets broken.\r\n\r\n// NDepend.CQL.PureAttribute is defined in the \r\n// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'pure' methods.</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Naming Conventions" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Instance fields should be prefixed with a 'm_'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  !NameLike "^m_" AND \r\n  !IsStatic AND \r\n  !IsLiteral AND \r\n  !IsGeneratedByCompiler  AND \r\n  !IsSpecialName AND \r\n  !IsEventDelegateObject \r\n\r\n// This naming convention provokes debate.\r\n// Don't hesitate to customize the regex of \r\n// NameLike to your preference.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Static fields should be prefixed with a 's_'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  !NameLike "^s_" AND \r\n  IsStatic AND \r\n  !IsLiteral AND \r\n  !IsGeneratedByCompiler AND \r\n  !IsSpecialName AND \r\n  !IsEventDelegateObject  \r\n\r\n// This naming convention provokes debate.\r\n// Don't hesitate to customize the regex of \r\n// NameLike to your preference.\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Interface name should begin with a 'I'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsInterface AND \r\n  !NameLike "^I" AND \r\n  !IsNested AND \r\n  !IsInFrameworkAssembly\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Abstract base class should be suffixed with 'Base'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsAbstract AND \r\n  IsClass AND\r\n\r\n  // equivalent to:   DepthOfDeriveFrom "System.Object" == 1\r\n  DepthOfInheritance == 1 AND \r\n\r\n  ((!IsGeneric AND !NameLike "Base$") OR\r\n   ( IsGeneric AND !NameLike "Base&lt;"))\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Exception class name should be suffixed with 'Exception'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsExceptionClass AND \r\n  !NameLike "Exception$" AND \r\n  !IsInFrameworkAssembly\r\n\r\n// The name of an exception class should end with \r\n// 'Exception'.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Attribute class name should be suffixed with 'Attribute'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsAttributeClass AND \r\n  !NameLike "Attribute$" AND \r\n  !IsInFrameworkAssembly\r\n</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types name should begin with an Upper character&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  // The name of a type should begin with an Upper letter.\r\n  !NameLike "^[A-Z]" AND     \r\n\r\n  // Except if it is generated by compiler or ...\r\n  !IsGeneratedByCompiler AND \r\n\r\n  // ... if it is declared in a tier assembly.\r\n  !IsInFrameworkAssembly     </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods name should begin with an Upper character&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  !NameLike "^[A-Z]" AND \r\n  !( IsClassConstructor OR IsConstructor OR \r\n     IsPropertyGetter  OR IsPropertySetter OR\r\n     IsIndexerGetter OR IsIndexerSetter OR\r\n     IsEventAdder OR IsEventRemover OR\r\n     IsOperator) AND \r\n  !IsGeneratedByCompiler AND \r\n  !IsInFrameworkAssembly\r\n\r\n// The name of a regular method should \r\n// begin with an Upper letter.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not name enum values 'Reserved'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  IsEnumValue AND \r\n  NameLike "Reserved"\r\n\r\n// This rule assumes that an enumeration member \r\n// with a name that contains "reserved" \r\n// is not currently used but is a placeholder to \r\n// be renamed or removed in a future version.\r\n// Renaming or removing a member is a breaking \r\n// change. You should not expect users to ignore\r\n// a member just because its name contains \r\n// "reserved" nor can you rely on users to read or \r\n// abide by documentation. Furthermore, because \r\n// reserved members appear in object browsers \r\n// and smart integrated development environments, \r\n// they can cause confusion as to which members \r\n// are actually being used.\r\n\r\n// Instead of using a reserved member, add a \r\n// new member to the enumeration in the future \r\n// version.\r\n// In most cases, the addition of the new \r\n// member is not a breaking change, as long as the \r\n// addition does not cause the values of the \r\n// original members to change.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Type names should not match namespaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  NameIs "Collections" OR\r\n  NameIs "Forms" OR\r\n  NameIs "System" OR\r\n  NameIs "UI"\r\n\r\n// Type names should not match the names of \r\n// namespaces defined in the .NET Framework \r\n// class library. Violating this rule can reduce \r\n// the usability of the library.</CQLQuery>
      <CQLGroup Name="Name too long" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid methods with name too long&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n  NameLike "^[^\&lt;\(]{35,}.*$" AND\r\n  !IsExplicitInterfaceImpl AND \r\n  !IsInFrameworkAssembly\r\n\r\n// The regex matches methods with name longer \r\n// than 35 characters.\r\n// Method Name doesn't contain the type and namespace \r\n// prefix, FullName does.\r\n// The regex computes the method name length from \r\n// the beginning until the first open parenthesis \r\n// or first lower than (for generic methods).\r\n// Explicit Interface Implementation methods are \r\n// discarded because their names are prefixed \r\n// with the interface name.\r\n      </CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid types with name too long&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE\r\n  NameLike "^[^\&lt;]{35,}.*$" AND\r\n  !IsNested AND \r\n  !IsInFrameworkAssembly\r\n\r\n// The regex matches types with name longer \r\n// than 35 characters.\r\n// Type Name doesn't contain the namespace \r\n// prefix, FullName does.\r\n// The regex computes the type name length from \r\n// the beginning until the end or the first lower than \r\n// (for generic types).\r\n// Nested types are discarded because their \r\n// names are prefixed with outer type's name.\r\n      </CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid fields with name too long&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE\r\n  NameLike "^[^\&lt;]{35,}.*$" AND\r\n  !IsInFrameworkAssembly\r\n\r\n// The regex matches fields with name longer \r\n// than 35 characters.\r\n// Field Name doesn't contain the type and \r\n// namespace prefix, FullName does.\r\n      </CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name=".NET Framework Usage" Active="False">
      <CQLGroup Name="System" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark ISerializable types with serializable&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n IsPublic AND !IsDelegate AND\r\n Implement "OPTIONAL:System.Runtime.Serialization.ISerializable" AND \r\n !HasAttribute "OPTIONAL:System.SerializableAttribute"\r\n\r\n// To be recognized by the CLR as serializable, \r\n// types must be marked with the SerializableAttribute \r\n// attribute even if the type uses a custom \r\n// serialization routine through implementation of \r\n// the ISerializable interface.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with assembly version&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.Reflection.AssemblyVersionAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The identity of an assembly is composed of \r\n// the following information:\r\n//    - Assembly name\r\n//    - Version number\r\n//    - Culture\r\n//    - Public key (for strong-named assemblies).\r\n// The .NET Framework uses the version number \r\n// to uniquely identify an assembly, and to bind \r\n// to types in strong-named assemblies. The \r\n// version number is used together with version \r\n// and publisher policy. By default, applications \r\n// run only with the assembly version with \r\n// which they were built.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with CLSCompliant&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.CLSCompliantAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The Common Language Specification (CLS) defines \r\n// naming restrictions, data types, and rules to which \r\n// assemblies must conform if they are to be used \r\n// across programming languages. Good design dictates \r\n// that all assemblies explicitly indicate CLS \r\n// compliance with CLSCompliantAttribute. If the \r\n// attribute is not present on an assembly, the \r\n// assembly is not compliant.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with ComVisible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.Runtime.InteropServices.ComVisibleAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The ComVisibleAttribute attribute determines \r\n// how COM clients access managed code. Good design \r\n// dictates that assemblies explicitly indicate \r\n// COM visibility. COM visibility can be set for \r\n// an entire assembly and then overridden for \r\n// individual types and type members. If the \r\n// attribute is not present, the contents of \r\n// the assembly are visible to COM clients.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark attributes with AttributeUsageAttribute&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nDeriveFrom "OPTIONAL:System.Attribute" AND\r\n!HasAttribute "OPTIONAL:System.AttributeUsageAttribute" AND\r\n!IsInFrameworkAssembly \r\n\r\n// When defining a custom attribute, mark it using \r\n// AttributeUsageAttribute to indicate where in the \r\n// source code the custom attribute can be applied.\r\n// An attribute's meaning and intended usage will \r\n// determine its valid locations in code. For example, \r\n// if you are defining an attribute that identifies \r\n// the person responsible for maintaining and enhancing \r\n// each type in a library, and responsibility is \r\n// always assigned at the type level, compilers should \r\n// allow the attribute on classes, enumerations, \r\n// and interfaces, but should not allow it on methods, \r\n// events, or properties. Organizational policies and\r\n// procedures would dictate whether the attribute \r\n// should be allowed on assemblies.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Remove calls to GC.Collect()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)"\r\n\r\n// It is preferrable to avoid calling GC.Collect() \r\n// explicitely in order to avoid some performance pitfall.\r\n// More in information on this here:\r\n// http://blogs.msdn.com/ricom/archive/2004/11/29/271829.aspx</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't call GC.Collect() without calling GC.WaitForPendingFinalizers()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  (IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR\r\n   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)") \r\n  AND\r\n  !IsDirectlyUsing "OPTIONAL:System.GC.WaitForPendingFinalizers()" \r\n\r\n// It is preferrable to avoid calling GC.Collect() \r\n// explicitely in order to avoid some performance \r\n// pitfall. But if you wish to call GC.Collect(), \r\n// you must do it this way:\r\n//   GC.Collect();\r\n//   GC.WaitForPendingFinalizers();\r\n//   GC.Collect();\r\n// To make sure that finalizer got executed, and \r\n// object with finalizer got cleaned properly.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Enum Storage should be Int32&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  NameIs "value__" AND \r\n  !IsOfType "OPTIONAL:System.Int32" AND\r\n  !IsInFrameworkAssembly\r\n\r\n// An enumeration is a value type that defines \r\n// a set of related named constants. By default, \r\n// the System.Int32 data type is used to store \r\n// the constant value. Even though you can change \r\n// this underlying type, it is not necessary or \r\n// recommended for most scenarios. Note that there \r\n// is no significant performance gain in using \r\n// a data type smaller than Int32. If you cannot \r\n// use the default data type, you should use one \r\n// of the CLS-compliant integral types, Byte, \r\n// Int16, Int32, or Int64, to ensure that all of \r\n// the enumeration's values are representable in \r\n// CLS-compliant programming languages.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not raise too general exception types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  // The following exception types are too general \r\n  // to provide sufficient information to the user:\r\n  ( ( DepthOfCreateA "OPTIONAL:System.Exception" == 1 OR \r\n      DepthOfCreateA "OPTIONAL:System.ApplicationException" == 1 OR \r\n      DepthOfCreateA "OPTIONAL:System.SystemException" == 1 )\r\n    // Test for non-constructor, else this constraint \r\n    // would warn on ctor of classes that derive \r\n    // from these exception types.\r\n    AND !IsConstructor )\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not raise reserved exception types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  // The following exception types are reserved \r\n  // and should be thrown only by the Common Language Runtime:\r\n  ( DepthOfCreateA "OPTIONAL:System.ExecutionEngineException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.IndexOutOfRangeException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.NullReferenceException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.OutOfMemoryException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.StackOverflowException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.InvalidProgramException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.AccessViolationException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.CannotUnloadAppDomainException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.BadImageFormatException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.DataMisalignedException" == 1 )\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Use integral or string argument for indexers&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\nIsIndexerGetter AND \r\n !( NameIs "get_Item(String)" OR \r\n    NameLike "get_Item\(Int" OR \r\n    NameLike "get_Item\(Byte" OR\r\n    NameLike "get_Item\(SByte" )\r\n\r\n// Indexers, that is, indexed properties, \r\n// should use integer or string types for the index. \r\n// These types are typically used for indexing \r\n// data structures and increase the usability of \r\n// the library. Use of the Object type should be \r\n// restricted to those cases where the specific \r\n// integer or string type cannot be specified at \r\n// design time. If the design requires other \r\n// types for the index, reconsider whether the \r\n// type represents a logical data store. If it \r\n// does not represent a logical data store, \r\n// use a method.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Uri fields should be of type System.Uri&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  (NameLike "Uri$" OR NameLike "Url$") AND !IsOfType "OPTIONAL:System.Uri"\r\n\r\n// A field which name end with 'Uri' is deemed \r\n// as representing a uri. Such field should be of \r\n// type System.Uri.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types should not extend System.ApplicationException&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE\r\n  DepthOfDeriveFrom "OPTIONAL:System.ApplicationException" == 1 AND\r\n  !IsInFrameworkAssembly\r\n\r\n// For .NET Framework version 1, it was \r\n// recommended to derive new exceptions from \r\n// ApplicationException. The recommendation has \r\n// changed and new exceptions should derive \r\n// from System.Exception or one of its \r\n// subclasses in the System namespace.</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Collection" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't use .NET 1.x HashTable and ArrayList&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE\r\n\r\n  // Prefer using the class \r\n  // System.Collections.Generic.Dictionary&lt;K,V&gt; over \r\n  // System.Collections.HashTable.\r\n  CreateA "OPTIONAL:System.Collections.HashTable" OR\r\n\r\n  // Prefer using the class \r\n  // System.Collections.Generic.List&lt;T&gt; over\r\n  // System.Collections.ArrayList.\r\n  CreateA "OPTIONAL:System.Collections.ArrayList"\r\n\r\n// You can be forced to use HashTable or ArrayList \r\n// because if you are using tier code that requires \r\n// working with these classes or because you are \r\n// coding with .NET 1.x.</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Caution with List.Contains()&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  IsDirectlyUsing "OPTIONAL:System.Collections.Generic.List&lt;T&gt;.Contains(T)" OR\r\n  IsDirectlyUsing "OPTIONAL:System.Collections.Generic.IList&lt;T&gt;.Contains(T)" OR\r\n  IsDirectlyUsing "OPTIONAL:System.Collections.ArrayList.Contains(Object)"\r\n\r\n// The cost of checking if a list contains an \r\n// object is proportional to the size of the list \r\n// (O(N) operation). For large lists and/or frequent \r\n// calls to Contains(), prefer using the \r\n// System.Collections.Generic.HashSet&lt;T&gt; class \r\n// where calls to Contains() takes a constant \r\n// time (O(0) operation).</CQLQuery>
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Prefer return collection abstraction instead of implementation&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  ReturnTypeIs "OPTIONAL:System.Collections.Generic.List&lt;T&gt;" OR \r\n  ReturnTypeIs "OPTIONAL:System.Collections.Generic.HashSet&lt;T&gt;" OR\r\n  ReturnTypeIs "OPTIONAL:System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;"\r\n\r\n// Most of the time, clients of a method doesn't \r\n// need to know the exact implementation of the \r\n// collection returned. It is preferrable to return \r\n// a collection interface such as IList&lt;T&gt;, \r\n// ICollection&lt;T&gt; or IEnumerable&lt;T&gt;.</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Runtime.InteropServices" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;P/Invokes should be static and not be visible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  !IsInFrameworkAssembly AND\r\n  (HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute") AND\r\n  ( IsPublic OR \r\n    !IsStatic)\r\n\r\n// Methods marked with the DllImportAttribute \r\n// attribute (or methods defined using the \r\n// Declare keyword in Visual Basic) use \r\n// Platform Invocation Services to access unmanaged \r\n// code. Such methods should not be exposed. Keeping \r\n// these methods private or internal ensures \r\n// that your library cannot be used to breach \r\n// security by allowing callers access to \r\n// unmanaged APIs they could not call otherwise.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Move P/Invokes to NativeMethods class&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  !IsInFrameworkAssembly AND\r\n  HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute" AND\r\n  !FullNameLike "NativeMethods."\r\n\r\n// Platform Invocation methods, such as those marked \r\n// with the System.Runtime.InteropServices.DllImportAttribute \r\n// attribute, or methods defined by using the Declare \r\n// keyword in Visual Basic, access unmanaged code. \r\n// These methods should be in one of the following classes:\r\n//\r\n//   - NativeMethods - This class does not suppress stack \r\n//     walks for unmanaged code permission. \r\n//     (System.Security.SuppressUnmanagedCodeSecurityAttribute \r\n//     must not be applied to this class.) \r\n//     This class is for methods that can be used \r\n//     anywhere because a stack walk will be performed.\r\n//\r\n//   - SafeNativeMethods - This class suppresses \r\n//     stack walks for unmanaged code permission. \r\n//     (System.Security.SuppressUnmanagedCodeSecurityAttribute \r\n//     is applied to this class.) \r\n//     This class is for methods that are safe \r\n//     for anyone to call. Callers of these methods \r\n//     are not required to do a full security review \r\n//     to ensure that the usage is secure because \r\n//     the methods are harmless for any caller.\r\n//\r\n//   - UnsafeNativeMethods - This class suppresses \r\n//     stack walks for unmanaged code permission. \r\n//     (System.Security.SuppressUnmanagedCodeSecurityAttribute \r\n//     is applied to this class.) This class is for \r\n//     methods that are potentially dangerous. Any \r\n//     caller of these methods must do a full security \r\n//     review to ensure that the usage is secure because \r\n//     no stack walk will be performed.\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;NativeMethods class should be static and internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE\r\n  !IsInFrameworkAssembly AND\r\n  ( NameIs "NativeMethods" OR\r\n    NameIs "SafeNativeMethods" OR\r\n    NameIs "UnsafeNativeMethods") AND\r\n  (IsPublic OR\r\n   !IsStatic)\r\n\r\n// Native Methods' classes are declared as internal \r\n// (Friend, in Visual Basic) and static.\r\n</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Threading" Active="True">
        <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method non-synchronized that read mutable states&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n (ReadsMutableObjectState OR ReadsMutableTypeState) AND \r\n !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor" AND \r\n !IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock"\r\n\r\n// Mutable object states are instance fields that \r\n// can be modifed throught the lifetime of the object.\r\n// Mutable type states are static fields that can be \r\n// modifed throught the lifetime of the program.\r\n// This query lists methods that read mutable state \r\n// without synchronizing access. In the case of \r\n// multi-threaded program, doing so can lead to \r\n// state corruption.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't create threads explicitely&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  CreateA "OPTIONAL:System.Threading.Thread"\r\n\r\n// Prefer using the thread pool instead of \r\n// creating manually your own thread.\r\n// Threads are costly objects. \r\n// They take approximately 200,000 cycles to \r\n// create and about 100,000 cycles to destroy.  \r\n// By default they reserve 1 megabyte of virtual \r\n// memory for its stack and use 2,000-8,000 \r\n// cycles for each context switch.\r\n// As a consequence, it is preferrable to let \r\n// the thread pool recycle threads.\r\n\r\n// Creating custom thread can also be the \r\n// sign of flawed design, where tasks and \r\n// threads have affinity. It is preferrable \r\n// to code tasks that can be ran on any thread.</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't use Thread.Sleep()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Sleep(Int32)"\r\n\r\n// Usage of Thread.Sleep() is a sign of \r\n// flawed design. More information on this here:\r\n// http://msmvps.com/blogs/peterritchie/archive/2007/04/26/thread-sleep-is-a-sign-of-a-poorly-designed-program.aspx\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't use Thread.Abort()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Abort()" OR\r\n  IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Abort(Object)" \r\n\r\n// Usage of Thread.Abort() is dangerous.\r\n// More information on this here:\r\n// http://www.interact-sw.co.uk/iangblog/2004/11/12/cancellation</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Monitor Enter/Exit must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Enter(Object)" AND\r\n !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Exit(Object)" </CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Monitor TryEnter/Exit must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n ( IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Enter(Object)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,Int32)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") AND\r\n !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Exit(Object)" </CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;ReaderWriterLock AcquireReaderLock/ReleaseLock must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  ( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") \r\nAND\r\n !( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseReaderLock()" OR \r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseLock()") </CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;ReaderWriterLock AcquireWriterLock/ReleaseLock must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  ( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") \r\nAND\r\n !( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseWriterLock()" OR \r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseLock()") </CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Xml" Active="True">
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Method should not return concrete XmlNode&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n( ReturnTypeIs "OPTIONAL:System.Xml.XmlDocument" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlAttribute" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlDocumentFragment" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlEntity" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlLinkedNode" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlNotation" OR\r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlNode" )\r\n\r\n// The class System.Xml.XmlNode implements the interface \r\n// System.Xml.Xpath.IXPathNavigable. It is preferrable \r\n// to return this interface instead of a concrete class.\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types should not extend System.Xml.XmlDocument&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE DepthOfDeriveFrom "OPTIONAL:System.Xml.XmlDocument" == 1\r\n\r\n// Do not create a subclass of XmlDocument if you want \r\n// to create an XML view of an underlying object \r\n// model or data source.</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="System.Globalization" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Float and Date Parsing must be culture aware&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS \r\n  FROM TYPES "OPTIONAL:System.DateTime", \r\n             "OPTIONAL:System.Single", \r\n             "OPTIONAL:System.Double",\r\n             "OPTIONAL:System.Decimal"\r\n  // The 'NameLike' CQL clause operates on the signature\r\n  // "methodName(type1,type2...typeN)"\r\n  WHERE (NameLike "Parse\(" OR NameLike "ToString\(") AND\r\n        !NameLike "IFormatProvider"</CQLQuery>
      </CQLGroup>
    </CQLGroup>
    <CQLGroup Name="Statistics" Active="False">
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used types (TypeRank)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeRank DESC\r\n\r\n// TypeRank values are computed by applying \r\n// the Google PageRank  algorithm on the \r\n// graph of types' dependencies. Types with \r\n// high Rank are the most used ones.\r\n// See the definition of the TypeRank metric here: \r\n// http://www.ndepend.com/Metrics.aspx#TypeRank</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used methods (MethodRank)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodRank DESC\r\n\r\n// MethodRank values are computed by applying \r\n// the Google PageRank  algorithm on the graph of \r\n// methods' dependencies. Methods with high Rank \r\n// are the most used ones. See the definition of \r\n// the MethodRank metric here:\r\n// http://www.ndepend.com/Metrics.aspx#MethodRank</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used namespaces (NamespaceCa)&lt;/Name&gt;\r\nSELECT TOP 50 NAMESPACES ORDER BY NamespaceCa DESC\r\n\r\n// The Afferent Coupling for a particular namespace \r\n// is the number of namespaces that depends directly \r\n// on it. Namespaces with high Ca are the most \r\n// used ones. \r\n// See the definition of the NamespaceCa metric here:\r\n// http://www.ndepend.com/Metrics.aspx#NamespaceCa</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used types  (TypeCa)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeCa DESC\r\n\r\n// The Afferent Coupling for a particular type \r\n// is the number of types that depends directly \r\n// on it. Types with high Ca are the most used ones.\r\n// See the definition of the TypeCa metric here:\r\n// http://www.ndepend.com/Metrics.aspx#TypeCa</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used methods (MethodCa)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodCa DESC\r\n\r\n// The Afferent Coupling for a particular method \r\n// is the number of methods that depends directly \r\n// on it. Methods with high Ca are the most used ones\r\n// See the definition of the MethodCa metric here:\r\n// http://www.ndepend.com/Metrics.aspx#MethodCa</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces that use many other namespaces (NamespaceCe)&lt;/Name&gt;\r\nSELECT TOP 50 NAMESPACES ORDER BY NamespaceCe DESC\r\n\r\n// The Efferent Coupling for a particular namespace \r\n// is the number of namespaces it directly depends on.\r\n// Namespaces declared in Framework assemblies are \r\n// taken account.\r\n// See the definition of the NamespaceCe metric here:\r\n// http://www.ndepend.com/Metrics.aspx#NamespaceCe</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types that use many other types (TypeCe)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeCe DESC\r\n\r\n// The Efferent Coupling for a particular type\r\n// is the number of types it directly depends on.\r\n// Types declared in Framework assemblies are \r\n// taken account.\r\n// See the definition of the TypeCe metric here:\r\n// http://www.ndepend.com/Metrics.aspx#TypeCe</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods that use many other methods (MethodCe)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodCe DESC\r\n\r\n// The Efferent Coupling for a particular method \r\n// is the number of methods it directly depends on.\r\n// Methods declared in Framework assemblies are \r\n// taken account.\r\n// See the definition of the MethodCe metric here http://www.ndepend.com/Metrics.aspx#MethodCe</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level assemblies (AssemblyLevel)&lt;/Name&gt;\r\nSELECT ASSEMBLIES ORDER BY AssemblyLevel DESC\r\n\r\n// Classify assemblies by their Level values.\r\n// See the definition of the AssemblyLevel metric here:\r\n// http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level namespaces (NamespaceLevel)&lt;/Name&gt;\r\nSELECT NAMESPACES ORDER BY NamespaceLevel DESC\r\n\r\n// Classify namespaces by their Level values.\r\n// See the definition of the NamespaceLevel metric here:\r\n// http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level types (TypeLevel)&lt;/Name&gt;\r\nSELECT TYPES ORDER BY TypeLevel DESC\r\n\r\n// Classify types by their Level values.\r\n// See the definition of the TypeLevel metric here:\r\n// http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
      <CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level methods (MethodLevel)&lt;/Name&gt;\r\nSELECT METHODS ORDER BY MethodLevel DESC\r\n\r\n// Classify methods by their Level values.\r\n// See the definition of the MethodLevel metric here:\r\n// http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Samples of Custom Constraints" Active="False">
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the assembly Asm1 is not using the assembly Asm2&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm2" AND\r\n  NameIs "Asm1"\r\n\r\n// The OPTIONAL: prefix is just use to avoid an \r\n//error because there is currently no assembly named Asm2.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the namespace N1.N2 is not using the namespace N3.N4.N5&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:N3.N4.N5" AND\r\n  NameIs "N1.N2"\r\n\r\n// The OPTIONAL: prefix is just use to avoid an \r\n// error because there is currently no namespace named N3.N4.N5.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the assembly Asm1 is only using the assemblies Asm2, Asm3 or mscorlib&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  ( !IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm2" OR\r\n    !IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm3" OR\r\n    !IsDirectlyUsing "ASSEMBLY:mscorlib" OR\r\n    AsmCe != 3) // Must not be used more than 3 assemblies \r\n                // AsmCe = Efferent Coupling for assembly\r\nAND \r\n  NameIs "Asm1"\r\n  // The OPTIONAL: prefix is just use to avoid an \r\n  // error because there is currently no assembly \r\n  // named Asm2 or Asm3.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the namespace N1.N2 is only using the namespaces N3.N4, N5 or System&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  ( !IsDirectlyUsing "OPTIONAL:NAMESPACE:N3.N4" OR\r\n    !IsDirectlyUsing "OPTIONAL:NAMESPACE:N5" OR\r\n    !IsDirectlyUsing "NAMESPACE:System" OR\r\n    AsmCe != 3) // Must not be used more than 3 assemblies \r\n                // AsmCe = Efferent Coupling for assembly\r\nAND \r\n  NameIs "Asm1"\r\n  // The OPTIONAL: prefix is just use to avoid an\r\n  // error because there is currently no namespace \r\n  // named N3.N4 or N5.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that AsmDrawing is the only assembly that is using System.Drawing&lt;/Name&gt;\r\nWARN IF Count&gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:System.Drawing" AND\r\n  !NameIs "AsmDrawing"\r\n\r\n// The OPTIONAL: prefix is just use to avoid \r\n// an error because System.Drawing might not \r\n// be currently referenced.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that only 3 assemblies are using System.Drawing&lt;/Name&gt;\r\nWARN IF Count &gt; 3 IN SELECT ASSEMBLIES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:System.Drawing"\r\n\r\n// The OPTIONAL: prefix is just use to avoid an \r\n// error because System.Drawing might not be \r\n// currently referenced.\r\n</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  IsDirectlyUsing "OPTIONAL:Foo.Fct1()" AND\r\n  !IsDirectlyUsing "OPTIONAL:Foo.Fct2(Int32)"\r\n  // The OPTIONAL: prefix is just use to avoid an error \r\n  // because there is currently no methods named \r\n  // Foo.Fct1() or Foo.Fct2(Int32)</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all types that derive from Foo, also implement IFoo&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  DeriveFrom "OPTIONAL:TYPE:Foo" AND\r\n  !Implement "OPTIONAL:TYPE:IFoo"\r\n  // The OPTIONAL: prefix is just use to avoid an \r\n  // error because there is currently no class named \r\n  // Foo and no interface named IFoo</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all types that has the attribute FooAttribute are declared in the namespace N1.N2&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TYPES \r\n  OUT OF NAMESPACES "OPTIONAL:N1.N2" \r\n  WHERE \r\n    HasAttribute "OPTIONAL:FooAttribute"\r\n\r\n  // The OPTIONAL: prefix is just use to avoid an \r\n  // error because there is currently no attribute \r\n  // class named FooAttribute and no namespace named N1.N2</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all synchronization objects are only used from the namespaces under MyNamespace.Sync&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES \r\n  WHERE \r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Mutex" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.EventWaitHandle" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Semaphore" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Interlocked" \r\n  AND !NameLike "^MyNamespace.Sync"\r\n\r\n  // The OPTIONAL: prefix is just use to avoid an \r\n  // error because there some code elemnts might \r\n  // not currently exists.</CQLQuery>
      <CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the graph of namespaces dependencies of the assembly Asm is acyclic&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  NameIs "OPTIONAL:Asm" AND\r\n  ContainsNamespaceDependencyCycle\r\n\r\n  // The OPTIONAL: prefix is just use to avoid \r\n  // an error because there is currently no assembly \r\n  // named Asm</CQLQuery>
      <CQLGroup Name="Check Coverage on particular Code Elements" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the assembly Asm is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  NameIs "Asm" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data \r\n// must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the namespace N1.N2 is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\n  NameIs "N1.N2" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data \r\n// must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the class Namespace.Foo is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  FullNameIs "Namespace.Foo" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data \r\n// must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the class Namespace.Foo.Method(Int32) is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  FullNameIs "Namespace.Foo.Method(Int32)" AND \r\n  PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data \r\n// must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done throught the menu: \r\n//   NDepend -&gt; Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: \r\n// Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
      </CQLGroup>
      <CQLGroup Name="Custom Naming Conventions" Active="True">
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all types that derive from Foo, has a name that ends up with Foo&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  DeriveFrom "OPTIONAL:TYPE:Foo" AND\r\n  !NameLike "Foo$"\r\n  // The OPTIONAL: prefix is just use to avoid \r\n  // an error because there is currently no \r\n  // class named Foo</CQLQuery>
        <CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all namespaces begins with CompanyName.ProductName&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\n  !NameLike "^CompanyName.ProductName"\r\n  AND !IsInFrameworkAssembly </CQLQuery>
      </CQLGroup>
    </CQLGroup>
  </CQLQueries>
</NDepend>